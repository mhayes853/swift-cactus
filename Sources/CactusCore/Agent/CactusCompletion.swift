import Foundation

// MARK: - CactusCompletion

/// The result produced by one completion turn.
///
/// This value only contains entries appended during the turn that produced it.
/// It does not represent the session's full transcript.
public struct CactusCompletion<Output: Sendable>: Sendable {
  /// The parsed output for the completion turn.
  public let output: Output

  /// The entries appended during this completion turn.
  public let entries: [CactusCompletionEntry]

  /// Metrics captured for this completion turn.
  public let metrics: CactusGenerationMetrics

  init(output: Output, entries: [CactusCompletionEntry]) {
    precondition(!entries.isEmpty, "Entries must not be empty.")
    precondition(entries.last?.metrics != nil, "The last entry must have metrics.")
    self.output = output
    self.entries = entries
    self.metrics = entries[entries.index(before: entries.endIndex)].metrics!
  }
}

extension CactusCompletion: Equatable where Output: Hashable {}
extension CactusCompletion: Hashable where Output: Hashable {}

// MARK: - CactusCompletionEntry

/// A completion entry that wraps a transcript entry and its metrics.
public struct CactusCompletionEntry: Hashable, Sendable, Identifiable {
  /// The transcript entry associated with this completion entry.
  public var transcriptEntry: CactusTranscript.Element

  /// Generation metrics for this entry if the entry was generated by the model.
  ///
  /// These are ommitted for function call response entries.
  public var metrics: CactusGenerationMetrics?

  public var id: CactusGenerationID {
    self.transcriptEntry.id
  }

  /// Creates a completion entry.
  ///
  /// - Parameters:
  ///   - transcriptEntry: The transcript element associated with this completion entry.
  ///   - metrics: Optional generation metrics associated with this entry.
  public init(transcriptEntry: CactusTranscript.Element, metrics: CactusGenerationMetrics? = nil) {
    self.transcriptEntry = transcriptEntry
    self.metrics = metrics
  }
}
